///
// Dependencies
///

var _ = require('lodash');
var utils = require('./utils');

// NOTE: Taken verbatim from node-waterline-mysql
// Hack for development - in future versions, allow
// logger to be injected (see wl2
// or tweet @mikermcneil for status of this feature or
// to help out)
var log = (process.env.LOG_QUERIES === 'true') ? console.log : function () {};

/**
 * SQL-related utilities, based heavily on sails-mysql (essentially
 * a limited-scope port).
 */
var sql = module.exports = {
  /**
   * Create a schema csv for a DDL query.
   */
  schema: function(table, attributes) {
    return sql.build(table, attributes, sql._schema);
  },

  _schema: function(table, attribute, attrName) {
  	log('sql._schema', table, attribute, attrName);

    attrName = utils.escapeId(attrName);
    var type = sqlTypeCast(attribute);

    // Process PK field
    if(attribute.primaryKey) {

      var columnDefinition = attrName + ' ' + type;

      // If type is an integer, set auto increment
      if(type === 'SMALLINT' || type === 'INTEGER' || type === 'BIGINT') {
        return columnDefinition + (
          ' NOT NULL GENERATED BY DEFAULT AS IDENTITY ' +
          '(START WITH 1, INCREMENT BY 1) PRIMARY KEY'
        );
      }

      // Just set NOT NULL on other types
      return columnDefinition + ' NOT NULL PRIMARY KEY';
    }

    // Process NOT NULL field.
    // if notNull is true, set NOT NULL constraint
    var nullPart = '';
    if (attribute.notNull) {
      nullPart = ' NOT NULL ';
    }

    // Process UNIQUE field
    if(attribute.unique) {
      return attrName + ' ' + type + nullPart + ' UNIQUE';
    }

    // Process INDEX field (NON-UNIQUE KEY)
    if(attribute.index) {
      return attrName + ' ' + type + nullPart + ', INDEX(' + attrName + ')';
    }

    return attrName + ' ' + type + ' ' + nullPart;
  },

  // Put together the CSV aggregation
  // separator => optional, defaults to ', '
  // keyOverride => optional, overrides the keys in the dictionary
  //          (used for generating value lists in IN queries)
  // parentKey => key of the parent to this object
  build: function(collectionName, collection, fn, separator, keyOverride, parentKey) {
  	log('sql.build', collectionName, collection, separator, keyOverride, parentKey);

    separator = separator || ', ';
    var $sql = [];
    _.each(collection, function(value, key) {
      $sql.push(fn(collectionName, value, keyOverride || key, parentKey));
    });

    return $sql.join(separator);
  },

  /**
   * Builds a waterline-normalized schema from columns, indices, and primary
   * keys given.
   *
   * Columns will be an array containing objects with the following
   * structure:
   *
   * {
   *   TABLE_SCHEM: String,
   *   TABLE_NAME: String,
   *   COLUMN_NAME: String,
   *   DATA_TYPE: Integer,
   *   TYPE_NAME: String,
   *   COLUMN_SIZE: Integer,
   *   BUFFER_LENGTH: Integer,
   *   DECIMAL_DIGITS: Integer,
   *   NUM_PREC_RADIX: Integer,
   *   NULLABLE: Integer,
   *   REMARKS: String,
   *   COLUMN_DEF: null,
   *   SQL_DATA_TYPE: Integer,
   *   SQL_DATETIME_SUB: Integer,
   *   CHAR_OCTET_LENGTH: Integer,
   *   ORDINAL_POSITION: Integer,
   *   IS_NULLABLE: String ('YES' or 'NO'),
   *   SCOPE_CATALOG: null,
   *   SCOPE_SCHEMA: null,
   *   SCOPE_TABLE: null,
   *   SOURCE_DATA_TYPE: Integer,
   *   IS_AUTOINCREMENT: String ('YES' or 'NO'),
   *   IS_GENERATEDCOLUMN: String ('YES' or 'NO'),
   *   SCOPE_CATLOG: null
   * }
   *
   * Indices will be an array containing objects with the following
   * structure:
   *
   * {
   *   TABLE_CAT: String,
   *   TABLE_SCHEM: String,
   *   TABLE_NAME: String,
   *   NON_UNIQUE: Boolean,
   *   INDEX_QUALIFIER: String,
   *   INDEX_NAME: String,
   *   TYPE: Integer,
   *   ORDINAL_POSITION: Integer,
   *   COLUMN_NAME: String,
   *   ASC_OR_DESC: String ('A' or 'D'),
   *   CARDINALITY: null,
   *   PAGES: null,
   *   FILTER_CONDITION: null
   * }
   *
   * Primary keys will be an array containing objects with the
   * following structure:
   *
   * {
   *   TABLE_CAT: String,
   *   TABLE_SCHEM: String,
   *   TABLE_NAME: String,
   *   COLUMN_NAME: String,
   *   KEY_SEQ: Integer (which part of the key this column is),
   *   PK_NAME: String
   * }
   *
   * Syncronously returns an object with the following structure:
   *
   * {
   *   [attributeName]: {
   *     type: String,
   *     defaultsTo: Mixed,
   *     autoIncrement: Boolean,
   *     primaryKey: Boolean / undefined,
   *     unique: Boolean / undefined,
   *     indexed: Boolean / undefined,
   *   }
   * }
   */
  normalizeSchema: function(columns, indices, primaryKeys) {
    var schema = _.reduce(columns, function(memo, field) {
      var attr = field.COLUMN_NAME;
      memo[attr] = {
        type: waterlineTypeCast(field.TYPE_NAME),
        defaultsTo: field.COLUMN_DEF,
        autoIncrement: field.IS_AUTOINCREMENT === 'YES',
      };

      if(attr.type === 'string' && ! _.isUndefined(field.COLUMN_SIZE)) {
        memo[attr].size = field.COLUMN_SIZE;
      }

      return memo;
    }, {});

    // Add index information
    _.forEach(indices, function(index) {
      var attr = index.COLUMN_NAME;
      if(! schema[attr]) return;
      schema[attr].indexed = true;
      index.NON_UNIQUE || (schema[attr].unique = true);
    });

    // Add primary key information
    _.forEach(primaryKeys, function(pk) {
      var attr = pk.COLUMN_NAME;
      if(! schema[attr]) return;
      schema[attr].primaryKey = true;
    });

    return schema;
  },

  mergeGeneratedKeys: function(schema, row, generatedKeys) {
    var merged = _.extend({}, row);

    if(! _.isArray(generatedKeys) || generatedKeys.length < 1) {
      return merged;
    }

    var attrs = schema && schema.attributes;

    if(! attrs) {
      console.error('Invalid schema:', schema);
      throw new Error('Cannot merge generated keys into row data: Invalid schema');
    }

    var pkField;
    _.forEach(attrs, function(value, key) {
      if(_.isObject(value) && value.primaryKey) {
        pkField = key;
        return false;
      }
    });
    
    if(! pkField) {
      return merged;
    }

		if(_.isUndefined(merged[pkField])) {
			merged[pkField] = _.first(generatedKeys)['1'];
		}

    return merged;
  },

  normalizeResults: function(tableSchema, results) {
    var processByType = {
      datetime: function(val) {
        return new Date(val);
      },

      date: function(val) {
        return new Date(val);
      },
    };

    var attrs = tableSchema.attributes;
    _.forEach(results, function(row) {
      _.forEach(row, function(val, key) {
        var attr = attrs[key];
        if(! attr) return;

        var type = (_.isObject(attr) && attr.type) || attr;
        if(! processByType[type]) return;
        row[key] = processByType[type](val);
      });
    });

    return results;
  },
};

// Cast waterline types into SQL data types
function sqlTypeCast(attr) {
  var type;
  if(_.isObject(attr) && _.has(attr, 'type')) {
    type = attr.type; 
  } else {
    type = attr;
  }
  
  type = type && type.toLowerCase();

  var attrSize = (
    ! _.isUndefined(attr.size) &&
    ! Number.isNaN(attr.size) &&
    (parseInt(attr.size) == parseFloat(attr.size)) &&
    (parseInt(attr.size) > 0)
  ) ? parseInt(attr.size) : null;

  switch (type) {
    case 'string': {
      // Size refers to number of characters; 255 is default
      var size = attrSize || 255;
      return 'VARCHAR(' + size + ')';
    }

    case 'text':
    case 'mediumtext':
    case 'longtext':
    case 'array':
    case 'json':
      return 'CLOB';

    case 'boolean':
      return 'BOOLEAN';

    case 'int':
    case 'integer': {
      // Size refers to number of bits; 32 is default
      var size = attrSize || 32;

      switch (size) {
        case 8:
        case 16:
          return 'SMALLINT';
        case 32:
          return 'INTEGER';
        case 64:
          return 'BIGINT'
        default:
          return 'INTEGER';
      }
    }

    case 'float':
      return 'FLOAT';

    case 'double':
      return 'DOUBLE';
    
    case 'decimal':
      return 'DECIMAL';

    case 'date':
      return 'DATE';

    case 'datetime':
      return 'TIMESTAMP';

    case 'time':
      return 'TIME';

    case 'binary':
      return 'BLOB';

    default:
      console.error('Unregistered type given: ' + type);
      return 'CLOB';
  }
}

function waterlineTypeCast(attr) {
  var type;
  if(_.isObject(attr) && _.has(attr, 'type')) {
    type = attr.type; 
  } else {
    type = attr;
  }
  
  type = type && type.toLowerCase();

  switch (type) {
    case 'clob':
    case 'xml':
      return 'text';

    case 'varchar':
    case 'varchar for bit data':
    case 'char':
    case 'char for bit data':
    case 'long varchar':
    case 'long varchar for bit data':
      return 'string';

    case 'bigint':
    case 'integer':
    case 'smallint':
      return 'integer';

    case 'decimal':
    case 'numeric':
      return 'decimal';

    case 'double':
    case 'double precision':
      return 'double';

    case 'float':
    case 'real':
      return 'float';

    case 'date':
      return 'date';

    case 'time':
      return 'time';

    case 'timestamp':
      return 'datetime';

    case 'boolean':
      return 'boolean';

    case 'blob':
      return 'binary';

    default:
      throw new Error('Unregistered type given: ' + type);
  }
}
